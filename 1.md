## Socket族系统调用入口

所有Socket相关的系统调用都由函数 `sys_socketcall()` 进入, 源码如下:
```cpp
asmlinkage int
sys_socketcall(int call, unsigned long *args)
{
  int er;
  switch (call) {
    case SYS_SOCKET:
        er = verify_area(VERIFY_READ, args, 3 * sizeof(long));
        if(er)
            return er;
        return(sock_socket(get_fs_long(args+0),
                   get_fs_long(args+1),
                   get_fs_long(args+2)));
    case SYS_BIND:
        er = verify_area(VERIFY_READ, args, 3 * sizeof(long));
        if(er)
            return er;
        return(sock_bind(get_fs_long(args+0),
                 (struct sockaddr *)get_fs_long(args+1),
                 get_fs_long(args+2)));
    case SYS_CONNECT:
        er = verify_area(VERIFY_READ, args, 3 * sizeof(long));
        if(er)
            return er;
        return(sock_connect(get_fs_long(args+0),
                    (struct sockaddr *)get_fs_long(args+1),
                    get_fs_long(args+2)));
    ...
    default:
        return(-EINVAL);
  }
}
```
从上面的代码可以知道, 参数 `call` 指定要调用哪个具体的Socket族函数, 譬如要调用 `bind()` 函数就传入 `SYS_BIND` 值, 而具体函数相关的值就由参数 `args` 传入. 由于传入参数的值保存在用户空间, 所以必须使用 `get_fs_long()` 函数来把参数copy到内核空间.

在用户进程中, 我们可以使用 `socket()` 系统调用来创建一个 `socket` 句柄, `socket()` 函数的原型如下:
```cpp
int socket(int domain, int type, int protocol);
```
各个参数的含义如下:
* domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。
* type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。
* protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。

而其调用的内核函数就是 `sock_socket()`, 我们来看看 `sock_socket()` 函数的实现:
```cpp
static int
sock_socket(int family, int type, int protocol)
{
  int i, fd;
  struct socket *sock;
  struct proto_ops *ops;

  /* Locate the correct protocol family. */
  for (i = 0; i < NPROTO; ++i) {
    if (pops[i] == NULL) continue;
    if (pops[i]->family == family) break;
  }
  ...
  ops = pops[i];
  ...
  if (!(sock = sock_alloc(1))) {
    printk("sock_socket: no more sockets\n");
    return(-EAGAIN);
  }

  sock->type = type;
  sock->ops = ops;
  if ((i = sock->ops->create(sock, protocol)) < 0) {
    sock_release(sock);
    return(i);
  }

  if ((fd = get_fd(SOCK_INODE(sock))) < 0) {
    sock_release(sock);
    return(-EINVAL);
  }

  return(fd);
}
```
